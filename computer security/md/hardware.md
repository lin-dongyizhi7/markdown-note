## Introduction

### 课程组织

- **时间安排**：课程分为3个部分，分别在12月2日、9日和16日的周一从12:00到14:00进行。
- **阅读任务**：每堂课都有配套的阅读材料，要求学生仔细阅读并尝试理解。
- **期末考试**：定于次年1月13日11:00。

### 课程主题概览

1. **模块二回顾**：学习如何分析程序中的安全漏洞。
2. **模块三回顾**：探讨了可以滥用逻辑接口入侵系统的对手。
3. **当前模块重点**：将注意力转向考虑利用计算物理特性的对手。

### 物理层面对安全性的影响

- 讨论了看似安全的程序仍然可能通过隐蔽通道或侧信道泄漏信息的问题。
- **隐蔽通道**：两个协作方通过非通信渠道交换信息。
- **侧信道攻击**：攻击者通过观察非预期的通信渠道来提取受害者计算的信息。

### 具体案例分析

- Kocher(1996)展示了如何通过计时测量恢复密钥。
- Boneh和Brumley(2003)通过网络对标准OpenSSL RSA实现进行了远程攻击，成功恢复完整密钥。
- 探讨了基于缓存的侧信道攻击、推测执行攻击等高级话题。

### 性能增强技术引入的安全隐患

- 缓存、推测执行、重复数据删除、压缩等性能优化技术可能会引入可被攻击者利用的变化，导致新的安全隐患。
- 例如，Branch Prediction Analysis (BPA) 攻击证明，即使是经过随机化处理以防御侧信道攻击的RSA实现也可能存在严重的安全隐患。

### 实际应用示例

- 使用AES加密的服务器遭受基于缓存定时的攻击，导致密钥完全暴露。
- 加密VoIP通话中，即使使用了长度保持流密码进行加密，也能通过分析包长度识别出说话的具体短语，这表明简单的加密不足以保障隐私。

### 结束语

强调了彻底关闭这些侧信道可能导致的显著性能损失，并提出了需要从根本上重新思考如何设计和保护计算系统免受这类物理层面攻击的方法。

## cache-side

#### 一、缓存架构与性能特性

1. **缓存层级与延迟**  | 缓存类型   | 延迟（Intel i7-4770）    | 功能描述                         |
   | ---------- | ------------------------ | -------------------------------- |
   | L1缓存     | 4 cycles / ~1.1ns        | 存储最近访问数据，速度最快       |
   | DRAM主内存 | 36 cycles + 57ns / ~67ns | 低速大容量存储，缓存未命中时访问 |
2. **缓存结构分类**
   - **全相联缓存**：任意内存块可存入任意缓存行，成本高但灵活（如高端CPU的TLB）。
   - **直接映射缓存**：每个内存块对应唯一缓存组（如 `set index = 物理地址 % 缓存组数`）。
   - **组相联缓存**：折中方案（如Haswell L1为8路组相联，L3为16路组相联）。

#### 二、缓存侧信道攻击方法

1. **基于时间的攻击（Evict+Time）**

   - **步骤**：
     1. 受害者运行，攻击者记录初始缓存状态；
     2. 攻击者清除目标缓存组数据；
     3. 受害者再次运行，攻击者通过执行时间判断缓存是否命中。
   - **案例**：2005年Osvik等人利用此方法攻击AES加密的T-table查找。
2. **基于状态的攻击**

   - **Prime+Probe（填充-探测）**
     - 流程：攻击者先用自己的数据填充缓存→受害者运行修改缓存→攻击者重新访问数据，通过计时差异判断缓存是否被受害者占用。
     - 应用：2005年首次用于恢复AES密钥，依赖缓存组粒度的精确控制。
   - **Flush+Reload（清除-重新加载）**
     - 流程：利用 `Clflush`指令清除目标内存块→受害者运行可能加载该块→攻击者重新加载并测量时间（命中≈1ns，未命中≈67ns）。
     - 特点：分辨率高（L3缓存），带宽可达**500 KB/s（本地环境）**，2014年Yarom用于攻击GnuPG的RSA实现。
3. **攻击带宽与影响**  

   | 攻击场景        | 带宽范围  | 典型应用                       |
   | --------------- | --------- | ------------------------------ |
   | 本地攻击        | ~500 KB/s | 实时密钥恢复                   |
   | 远程攻击（EC2） | ~50 KB/s  | 跨虚拟机侧信道（如视频流泄漏） |

#### 三、防御策略

1. **软件层面**
   - **恒定时间编程**：确保内存访问和控制流不依赖秘密值（如避免 `if(secret) x=1 else x=0`这类分支）。
   - **数据随机化**：对敏感数据进行地址随机化，增加攻击者预测缓存位置的难度。
2. **硬件层面**
   - **缓存分区**：为不同进程分配独立缓存组（如Intel的Cache Allocation Technology）。
   - **安全随机化缓存**：动态改变缓存映射规则，使攻击无法稳定定位缓存组。
3. **局限性**：硬件防御需修改架构，软件防御可能引入性能损耗（如AES加密速度下降30%）。

#### 四、实战案例与研究

- **2005年AES攻击**：Osvik通过Prime+Probe攻击AES的T-table，利用密钥依赖的缓存访问模式恢复密钥。
- **2014年Flush+Reload**：Yarom证明L3缓存可被远程攻击，甚至通过JavaScript实施（如跨EC2实例视频流泄漏）。

---

### 关键问题

#### 问题1：为什么Flush+Reload攻击比Prime+Probe更高效？

**答案**：

- **Flush+Reload**利用 `Clflush`指令直接清除目标缓存块，避免了Prime+Probe中填充缓存的复杂步骤，减少了噪声干扰。
- 其计时精度直接对应单个内存块（而非缓存组），可精确判断目标是否被受害者访问，尤其适用于L3缓存（如Haswell的8192组结构）。

#### 问题2：恒定时间编程如何防御缓存侧信道攻击？

**答案**：

- 恒定时间编程要求程序的**内存访问模式和执行时间与秘密数据无关**。例如：
  - 避免条件分支依赖秘密值（如使用 `cmov`指令替代 `if-else`）；
  - 确保敏感数据的内存访问地址固定（如预分配所有可能用到的缓存块）。
- 此举消除了攻击者通过计时差异推断秘密的可能性，但需重新设计算法（如AES的恒定时间实现）。

#### 问题3：缓存侧信道攻击能否在虚拟机环境中实施？

**答案**：

- 可以。例如：
  - 2014年研究显示，攻击者可通过Amazon EC2虚拟机实施Flush+Reload攻击，带宽约**50 KB/s**，足以泄漏加密密钥或视频流内容。
  - 跨虚拟机攻击依赖共享物理缓存，攻击者与受害者需共享同一CPU核心的缓存资源（如多租户云环境）。

## Speculative evecution attack

#### 一、推测执行与分支预测器

1. **推测执行机制**

   - **目标**：通过提前执行预测的分支路径，减少流水线停顿，提升CPU吞吐量。
   - **流程**：分支指令→预测器判断走向→推测执行→结果验证→回滚错误路径。
   - **关键问题**：**微架构状态（如缓存、分支历史）在回滚后仍保留，成为泄漏途径**。
2. **分支预测器类型**  

   | 类型                 | 原理                                                                           | 典型实现                                   |
   | -------------------- | ------------------------------------------------------------------------------ | ------------------------------------------ |
   | **静态预测器** | 基于跳转方向（如向后跳转默认执行，向前跳转默认不执行）                         | BTFNT（Backward Taken, Forward Not Taken） |
   | **动态预测器** | 基于分支历史（1/2位计数器记录最近结果，如2位计数器状态：0=强不执行，3=强执行） | 2位饱和计数器 + 分支历史缓冲器（BHB）      |

#### 二、Spectre攻击详解

1. **Variant 1：条件分支诱导攻击**

   - **攻击代码示例**：
     ```c
     void f(int x) {  
       if (x < A_size) y = B[A[x] * 4096];  
     }  
     ```
   - **攻击步骤**：
     1. **训练阶段**：多次调用 `f(0)`、`f(1)`等合法输入，使分支预测器“学习”到分支通常执行。
     2. **攻击阶段**：传入非法输入（如 `x=128`），预测器错误允许分支执行，触发越界访问 `A[128]`。
     3. **数据提取**：通过**Prime+Probe**观测 `B[A[128]]`的缓存状态，推断 `A[128]`的值。
2. **Variant 2：间接跳转攻击**

   - **攻击场景**：利用间接跳转指令（如 `jmp [rcx]`）的预测漏洞。
   - **关键组件**：
     - **分支目标缓冲器（BTB）**：存储跳转目标地址，攻击者可通过伪造历史记录污染预测。
     - **攻击步骤**：
       1. 构造恶意代码片段（Gadget），包含敏感数据依赖的内存访问。
       2. 通过训练BTB，使预测器错误指向恶意Gadget的地址。
       3. 触发推测执行Gadget，通过缓存侧信道泄漏数据。

#### 三、防御措施对比

| 防御方法                     | 原理                                                       | 优势         | 不足                               |
| ---------------------------- | ---------------------------------------------------------- | ------------ | ---------------------------------- |
| **推测屏障（LFENCE）** | 在分支后插入屏障指令，阻止推测执行跨屏障传播               | 无需硬件修改 | 性能损耗显著，需精准定位插入位置   |
| **推测加载硬化**       | 使用掩码限制索引范围（如 `y = B[(A[x] * 4096) & mask]`） | 代码修改较少 | 仅适用于特定场景，可能引入逻辑错误 |
| **微架构状态回滚**     | 推测失败时回滚缓存、分支历史等状态                         | 防御彻底     | 需硬件支持，实现复杂度高           |
| **禁用推测执行**       | 通过BIOS/固件关闭推测执行功能                              | 防御绝对安全 | 性能下降可达50%以上                |

#### 四、挑战与未来方向

- **性能与安全的权衡**：激进防御（如禁用推测执行）严重影响CPU性能，需平衡风险。
- **复杂攻击面**：除缓存外，分支预测器、内存重排序等微架构组件均可能成为攻击目标。
- **解决方案趋势**：
  - 硬件层面：设计安全分支预测器（如加密的BTB/PHT）。
  - 软件层面：开发自动化工具（如Spectector）检测推测泄漏风险。

---

### 关键问题

#### 问题1：为什么分支预测器容易被Spectre攻击利用？

**答案**：分支预测器基于历史数据预测分支走向，攻击者可通过多次合法调用“训练”预测器，使其对非法输入做出错误预测。例如，Variant 1中通过频繁调用合法输入，使预测器认为分支总是执行，从而在传入非法输入时触发越界推测执行。

#### 问题2：推测屏障（LFENCE）的工作原理与局限性是什么？

**答案**：

- **原理**：LFENCE是一条x86指令，强制要求处理器在执行后续指令前，完成所有已发布的加载操作，阻止推测执行跨越屏障传播。
- **局限性**：
  1. 插入位置难以精准判断，过多插入会导致程序性能大幅下降；
  2. 无法防御不依赖分支预测的推测攻击（如Variant 2的间接跳转攻击）。

#### 问题3：微架构状态回滚为何难以在现有硬件中普及？

**答案**：

- **技术挑战**：微架构状态（如缓存内容、分支历史缓冲器）分布在多个硬件组件中，回滚需协调不同单元，实现复杂度极高。
- **兼容性问题**：现有CPU架构未设计状态回滚机制，需大规模硬件重新设计，成本巨大。
- **性能影响**：即使实现，状态回滚的时间开销可能抵消推测执行带来的性能提升。

## noninterference

#### 一、理论基础：小步语义与程序形式化

1. **程序语义建模**

   - **内存状态**：`σ ∈ Mems`表示变量到自然数的映射，如 `[x↦1, y↦2]`。
   - **程序行为**：通过**小步语义**定义每条指令的执行效果，如：
     - **赋值语句**：`⟨x←e, m⟩ → ⟨stop, m[x↦v]⟩`，其中 `v=⟦e⟧(m)`。
     - **条件语句**：`⟦e⟧≠0 ⇒ ⟨if(e){s1}else{s2}, m⟩ → ⟨s1, m⟩`。
2. **攻击者模型**

   - **变量分类**：
     - **公共变量**（`x_public`）：攻击者可观测最终值。
     - **秘密变量**（`x_secret`）：攻击者不可直接观测，需通过侧信道推断。

#### 二、非干扰的形式化定义

1. **核心思想**

   - **公共等价性**：若两个内存状态 `m`和 `m'`的所有公共变量值相同（`m ~ m'`），则程序执行后结果状态也应公共等价（`⟨⟨Prg⟩⟩(m) ~ ⟨⟨Prg⟩⟩(m')`）。
   - **直观意义**：秘密变量的变化不应影响公共变量的输出。
2. **示例分析**  

   | 程序编号 | 代码示例                               | 非干扰性 | 分析                                                               |
   | -------- | -------------------------------------- | -------- | ------------------------------------------------------------------ |
   | f1       | `xpublic = xsecret + 1`              | ❌       | 秘密变量 `xsecret`直接影响公共变量 `xpublic`，违反非干扰。     |
   | f2       | `xsecret = 0; xpublic = xsecret + 1` | ✅       | 秘密变量被重置为0，公共变量仅依赖固定值，不泄漏秘密信息。          |
   | f5       | `if(xsecret==0) xpublic=1 else 0`    | ❌       | 条件分支依赖秘密变量，公共变量值随 `xsecret`变化，存在泄漏风险。 |

#### 三、安全验证方法

1. **静态 enforcement：类型系统**

   - **上下文标注**：为变量分配安全标签 `Γ(x_public)=public`，`Γ(x_secret)=secret`。
   - **赋值规则**：要求 `Γ(e)⊔pc ⊆ Γ(x)`，如：
     - 若 `e`为 `secret`且 `pc`为 `public`，则 `x`必须为 `secret`（`public⊔secret=secret`）。
   - **条件语句**：分支条件的标签需与语句上下文合并（`pc⊔Γ(e) ⊢ stmt`）。
2. **动态 enforcement：运行时监控**

   - **上下文跟踪**：通过 `Δ: Vars∪{pc}→{public, secret}`记录变量标签。
   - **赋值检查**：执行 `x←e`时，验证 `Δ(e)⊔Δ(pc) ⊆ Δ(x)`，否则阻止赋值或触发安全异常。

#### 四、关键价值与挑战

- **理论价值**：为程序安全提供数学化证明框架，可通过符号执行、抽象解释等技术自动化验证。
- **实践挑战**：
  - 静态类型系统需侵入式代码标注，增加开发成本。
  - 动态监控引入运行时开销，可能影响程序性能。

---

### 关键问题

#### 问题1：非干扰理论与侧信道攻击的本质区别是什么？

**答案**：

- **非干扰理论**关注**逻辑层面的信息流动控制**，通过形式化方法确保秘密变量不影响公共输出；
- **侧信道攻击**利用**物理层面的实现细节**（如缓存延迟、功耗）泄漏信息，属于非预期的物理副作用。

#### 问题2：静态类型系统如何具体实现非干扰验证？

**答案**：

- 通过**安全标签传播**实现：
  1. 为每个变量和表达式标注 `public/secret`标签；
  2. 赋值语句要求目标变量标签不低于源标签与上下文标签的并集（如 `secret`值不能直接赋给 `public`变量）；
  3. 条件分支的条件标签会提升语句块的上下文标签，防止秘密分支影响公共路径。

#### 问题3：动态 enforcement 相比静态 enforcement 的优缺点是什么？

**答案**：  

| 维度               | 静态 enforcement           | 动态 enforcement               |
| ------------------ | -------------------------- | ------------------------------ |
| **优点**     | 无运行时开销，提前阻断风险 | 无需修改代码，适应遗留系统     |
| **缺点**     | 需全程类型标注，灵活性低   | 引入性能损耗，无法防御所有攻击 |
| **典型场景** | 安全关键系统（如密码算法） | 动态语言或不可修改的二进制程序 |

## detecting speculative leaks

#### 一、Spectre攻击核心原理

1. **推测执行机制**

   - CPU通过**分支预测器**（如2位动态计数器）提前执行预测路径，若预测错误则回滚**架构状态**（寄存器、内存），但**微架构状态**（缓存内容、分支历史缓冲器BHB）保留，成为泄漏途径。
   - **攻击触发条件**：攻击者通过训练分支预测器（如多次合法调用），诱导CPU对非法输入执行推测路径，例如：
     ```c
     void f(int x) { if (x < A_size) y = B[A[x]]; }  
     ```

     传入 `x=128`时，预测器误判分支执行，触发越界访问 `A[128]`，通过缓存侧信道（Prime+Probe）推断数据。
2. **微架构状态泄漏**

   - 攻击者可观测**内存访问位置**、**分支跳转目标**和**推测执行起止时间**，例如：
     - 推测执行中加载的 `B[A[x]]`会导致缓存命中，通过测量访问延迟推断 `A[x]`值。

#### 二、防御措施对比

| 防御类型             | 典型方法            | 原理                                                       | 优势         | 局限性                         |
| -------------------- | ------------------- | ---------------------------------------------------------- | ------------ | ------------------------------ |
| **软件防御**   | 推测屏障（LFENCE）  | 在分支后插入指令阻止推测跨屏障传播                         | 无需硬件修改 | 性能损耗高，插入位置难精准     |
|                      | 推测加载硬化（SLH） | 使用掩码限制索引范围（如 `y = B[(A[x] * 4096) & mask]`） | 代码侵入性低 | 仅适用于特定内存访问模式       |
| **硬件防御**   | 微架构状态回滚      | 推测失败时清除缓存、BHB等状态                              | 防御彻底     | 需硬件重新设计，兼容性差       |
| **编译器优化** | 自动插入屏障指令    | 如Clang/ICC在条件分支后插入LFENCE                          | 自动化程度高 | 可能漏检复杂路径（如间接跳转） |

#### 三、自动化检测工具：Spectector

1. **核心功能**

   - **符号执行**：将程序变量抽象为符号值，遍历所有可能路径，生成**路径条件**（path condition）和**观测记录**。
   - **泄漏检测**：
     - **内存泄漏**：检查推测路径的内存访问是否依赖秘密变量（如 `pathCnd ∧ obsEqv(non-spec) ∧ ¬obsEqv(spec)`）。
     - **控制流泄漏**：验证分支跳转目标是否受秘密变量影响。
2. **工作流程**

   ```plaintext
   输入汇编程序 → 符号执行生成路径 → 约束求解（Z3）验证泄漏条件 → 输出安全报告  
   ```

#### 四、案例研究与结果

1. **测试配置**

   - **攻击变体**：15个Spectre V1案例（如例01-15），覆盖条件分支和间接跳转场景。
   - **编译器**：Microsoft Visual C++ (VCC)、Intel ICC (FEN)、Clang (SLH)，测试优化级别（-O0/-O2）。
2. **关键结果表**  

   | 案例编号 | VCC (-O0)                                            | VCC (-O2)    | ICC (-O0)    | ICC (-O2)    | Clang (-O0)  | Clang (-O2)  | 泄漏类型     |
   | -------- | ---------------------------------------------------- | ------------ | ------------ | ------------ | ------------ | ------------ | ------------ |
   | 01       | ◦（泄漏）                                           | ◦（泄漏）   | •◦（部分） | •◦（部分） | ◦（泄漏）   | ◦（泄漏）   | 内存访问     |
   | 08       | ◦（泄漏）                                           | •◦（优化） | ◦（泄漏）   | •◦（优化） | •◦（优化） | •◦（优化） | 控制流       |
   | 10       | ◦（泄漏）                                           | ◦（泄漏）   | ◦（泄漏）   | ◦（泄漏）   | ◦（泄漏）   | ◦（泄漏）   | 条件分支依赖 |
   | *注*   | **◦**：存在泄漏，**•◦**：通过屏障修复 |              |              |              |              |              |              |
3. **结论**

   - **未优化程序**：均存在推测泄漏，依赖分支预测器训练。
   - **编译器防御效果**：
     - Clang在-O2下修复率最高（如例08），但例10因控制流依赖秘密变量仍泄漏。
     - VCC漏检较多，印证“编译器无法保证全场景安全”（Paul Kocher结论）。

---

### 关键问题

#### 问题1：为什么分支预测器是Spectre攻击的核心目标？

**答案**：分支预测器基于历史数据预测分支走向，攻击者可通过频繁调用合法输入“训练”预测器，使其对非法输入做出错误预测。例如，多次调用 `f(0)`后，预测器会认为 `x < A_size`恒成立，从而在 `x=128`时触发越界推测执行，导致微架构状态泄漏。

#### 问题2：软件防御措施（如LFENCE）的本质局限性是什么？

**答案**：

1. **性能代价**：LFENCE强制刷新流水线，导致程序吞吐量下降（如例08插入屏障后执行时间增加10-100倍）。
2. **覆盖不全**：无法防御间接跳转攻击（如Spectre V2），且需人工或编译器精准定位插入位置，可能遗漏复杂路径（如嵌套分支）。

#### 问题3：Spectector相比传统静态分析工具有何优势？

**答案**：

- **形式化验证**：基于**推测非干扰性**理论，数学化证明程序安全，避免传统静态分析的误报/漏报。
- **全路径覆盖**：符号执行遍历所有推测路径，包括罕见分支和深层嵌套场景（如例15的多层条件判断），而传统工具可能因路径爆炸无法处理。
- **硬件无关性**：不依赖具体CPU微架构，适用于跨平台漏洞检测。

## Readind

#### 文档1：《Flush+Reload: A High Resolution, Low Noise, L3 Cache Side-Channel Attack》

1. **攻击原理**：
   - 利用Intel x86处理器的 `clflush`指令清空缓存，通过测量内存重新加载时间判断受害者是否访问特定内存块，**分辨率可达L3缓存**，支持跨核心攻击。
   - **核心步骤**：`Flush`（清除缓存）→ 受害者运行 → `Reload`（重新加载并计时），通过缓存命中/未命中的时间差异（L1约1ns，DRAM约67ns）推断信息。
2. **实战案例**：
   - 攻击GnuPG的RSA实现，**单轮解密可恢复96.7%-98.7%的密钥位**，跨虚拟机场景仍有效（成功率96.7%）。
3. **防御措施**：
   - 软件：恒定时间编程、避免密钥依赖内存访问；硬件：缓存分区、限制 `clflush`指令权限。

#### 文档2：《Cache Attacks and Countermeasures: the Case of AES》

1. **攻击方法**：
   - **Prime+Probe**：填充缓存→受害者运行→探测缓存状态，通过缓存集竞争推断内存访问模式，如攻击AES的T-table查找，**800次写入可恢复完整密钥**（耗时65ms）。
   - **Evict+Time**：清除目标缓存→测量加密时间差异，依赖高分辨率时钟，但噪声较大。
2. **防御策略**：
   - 禁用缓存共享、数据随机化、使用无表算法（如bitslice实现），但性能损耗显著（如AES速度下降30%）。

#### 文档3：《Spectre Attacks: Exploiting Speculative Execution》

1. **攻击机制**：
   - **Variant 1**：训练分支预测器触发越界访问（如 `if(x<A_size) y=B[A[x]]`），利用缓存侧信道泄漏数据。
   - **Variant 2**：污染分支目标缓冲器（BTB），诱导推测执行任意代码，**跨虚拟机和JavaScript场景均有效**。
2. **影响范围**：
   - 影响Intel/AMD/ARM处理器，**主流编译器（Clang/ICC/MSVC）插入LFENCE等屏障指令**，但存在漏检可能（如MSVC对复杂路径防护不足）。

#### 文档4：《Language-Based Information Flow Basics》

1. **理论基础**：
   - **非干扰性（Noninterference）**：定义程序公共变量输出不依赖秘密变量输入，通过**小步语义形式化验证**，要求等价初始状态的公共输出一致。
   - **类型系统**：为变量标注 `public/secret`标签，静态分析赋值规则（如 `Γ(e)⊔pc⊆Γ(x)`），动态监控内存访问防止非法信息流。

#### 文档5：《SPECTECTOR: Principled Detection of Speculative Information Flows》

1. **工具原理**：
   - 基于**符号执行和SMT求解**，分析推测执行路径的内存/控制流泄漏，定义“推测非干扰性”（Speculative Non-Interference），要求推测执行不泄漏额外信息。
2. **实验结果**：
   - 测试15个Spectre Variant 1样本，**未优化程序均存在泄漏**，Clang在-O2下修复率80%，但部分场景（如例10）因掩码不全仍存风险。
   - 分析Xen Hypervisor代码，检测时间与符号执行成本相当，**20.2%路径分析速度提升10倍**，7.9%路径耗时增加10倍以上。

---

### 文档对比

| **维度**     | **Flush+Reload**          | **Prime+Probe**       | **Spectre**                    |
| ------------------ | ------------------------------- | --------------------------- | ------------------------------------ |
| **攻击类型** | 缓存侧信道（主动清除-重新加载） | 缓存侧信道（被动填充-探测） | 推测执行侧信道（分支预测欺骗）       |
| **核心技术** | `clflush`指令、跨核心攻击     | 缓存集竞争、时间差测量      | 分支预测器污染、微架构状态回滚       |
| **防御重点** | 限制 `clflush`、缓存分区      | 恒定时间算法、无表实现      | 插入推测屏障（LFENCE）、硬件状态回滚 |
| **典型场景** | 跨虚拟机密钥恢复（96.7%成功率） | AES密钥恢复（800次操作）    | JavaScript跨进程泄漏、内核攻击       |

---

### 关键问题

#### 问题1：Flush+Reload与Prime+Probe的本质区别是什么？

**回答**：

- **Flush+Reload**通过 `clflush`指令主动清除目标缓存块，依赖精确的时间测量判断缓存命中，**支持跨核心攻击**，噪声低且分辨率高（可达L3缓存）；
- **Prime+Probe**通过填充缓存集间接驱逐目标数据，依赖缓存集竞争关系推测访问，**需同核心执行**，受系统噪声影响较大。

#### 问题2：非干扰理论如何支持程序安全验证？

**回答**：

- 非干扰理论通过**形式化语义定义程序执行等价类**，要求秘密变量变化不影响公共输出。例如，若两个状态仅秘密变量不同，其公共变量输出必须一致。
- 通过**静态类型系统**（标注变量安全级别）和**动态监控**（运行时检查内存访问标签），确保信息流符合安全策略，如禁止 `secret`值直接赋值给 `public`变量。

#### 问题3：Spectector相比传统静态分析工具有何优势？

**回答**：

- **形式化验证**：基于推测非干扰性理论，数学化证明安全属性，避免传统工具的误报/漏报（如oo7仅检测固定代码模式，漏检复杂路径）。
- **全路径覆盖**：符号执行遍历所有推测路径，包括深层嵌套和罕见分支（如Xen Hypervisor的循环代码），而传统工具可能因路径爆炸失效。
- **跨平台兼容性**：不依赖具体微架构细节，适用于Intel/AMD/ARM处理器，而硬件依赖型工具（如依赖特定缓存结构）适用性有限。
