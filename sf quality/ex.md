根据提供的解答文档，以下是练习2的详细解析和答案：

### 练习2 解答

#### 变更请求SC1后的CI库存状态

在应用变更请求SC1后，CI库存更新如下：

| 配置项标识 | 版本        |
| ---------- | ----------- |
| EC1        | 1, 2, 2.1.1 |
| EC1.1      | 1, 1.1.1    |
| EC1.2      | 1, 2, 2.1.1 |
| EC1.1.1    | 1, 1.1.1    |
| EC1.1.2    | 1           |
| EC1.2.1    | 1, 2        |
| EC1.2.2    | 1, 1.1.1    |

这里，“2.1.1”表示为新客户C2创建的新变体，从版本2派生的第一个变体。

#### 变更请求SC2后的CI库存状态

进一步应用变更请求SC2后，CI库存再次更新如下：

| 配置项标识 | 版本                  |
| ---------- | --------------------- |
| EC1        | 1, 2, 2.1.1, 3, 2.1.2 |
| EC1.1      | 1, 1.1.1, 2, 1.1.2    |
| EC1.2      | 1, 2, 2.1.1, 3, 2.1.2 |
| EC1.1.1    | 1, 1.1.1, 2, 1.1.2    |
| EC1.1.2    | 1                     |
| EC1.2.1    | 1, 2, 3               |
| EC1.2.2    | 1, 1.1.1              |

这里，“2.1.2”表示从变体2.1.1派生的新变体，“3”是新的主要版本，用于满足两个客户的需要。

#### A. CI库存状态展示

- **第一次变更（SC1）后**：

  - EC1: 增加了版本2.1.1。
  - EC1.1: 增加了版本1.1.1。
  - EC1.2: 增加了版本2.1.1。
  - EC1.1.1: 增加了版本1.1.1。
  - EC1.2.2: 增加了版本1.1.1。
- **第二次变更（SC2）后**：

  - EC1: 增加了版本3和2.1.2。
  - EC1.1: 增加了版本2和1.1.2。
  - EC1.2: 增加了版本3和2.1.2。
  - EC1.1.1: 增加了版本2和1.1.2。
  - EC1.2.1: 增加了版本3。

#### B. 替代配置的数量

根据变更后的CI库存状态，可以看到存在以下可选配置：

- EC1: 版本1, 2, 2.1.1, 3, 2.1.2
- EC1.1: 版本1, 1.1.1, 2, 1.1.2
- EC1.2: 版本1, 2, 2.1.1, 3, 2.1.2
- EC1.1.1: 版本1, 1.1.1, 2, 1.1.2
- EC1.1.2: 版本1
- EC1.2.1: 版本1, 2, 3
- EC1.2.2: 版本1, 1.1.1

由于EC1、EC1.1、EC1.2、EC1.1.1、EC1.2.1 和 EC1.2.2 各自有多个版本或变体，具体计算组合数量较为复杂。但根据提供的解决方案，最终形成了两种主要配置：C1和C2。

#### C. 每种替代配置的组成

根据提供的解决方案，展示了两种配置C1和C2的具体组成：

**配置C1**

| 配置项标识 | 版本 |
| ---------- | ---- |
| EC1        | 3    |
| EC1.1      | 2    |
| EC1.2      | 3    |
| EC1.1.1    | 2    |
| EC1.1.2    | 1    |
| EC1.2.1    | 3    |
| EC1.2.2    | 1    |

**配置C2**

| 配置项标识 | 版本  |
| ---------- | ----- |
| EC1        | 2.1.2 |
| EC1.1      | 1.1.2 |
| EC1.2      | 2.1.2 |
| EC1.1.1    | 1.1.2 |
| EC1.1.2    | 1     |
| EC1.2.1    | 3     |
| EC1.2.2    | 1.1.1 |

这些配置分别对应了不同客户的需求，确保每个客户都能获得满足其特定需求的产品版本。通过这种方式，可以有效地管理软件产品在面对不同客户需求时的演变过程。
