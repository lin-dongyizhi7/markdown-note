根据提供的解答文档，以下是练习2的详细解析和答案：

# 练习2 解答

## 变更请求SC1后的CI库存状态

在应用变更请求SC1后，CI库存更新如下：

| 配置项标识 | 版本        |
| ---------- | ----------- |
| EC1        | 1, 2, 2.1.1 |
| EC1.1      | 1, 1.1.1    |
| EC1.2      | 1, 2, 2.1.1 |
| EC1.1.1    | 1, 1.1.1    |
| EC1.1.2    | 1           |
| EC1.2.1    | 1, 2        |
| EC1.2.2    | 1, 1.1.1    |

这里，“2.1.1”表示为新客户C2创建的新变体，从版本2派生的第一个变体。

在SC1变更请求之后，不同的配置项（CI）增加的版本号不同（有的是2.1.1，有的是1.1.1），这是基于每个配置项当前的版本状态以及如何根据特定规则创建新变体来决定的。

### 解释

#### 版本编号规则

- **X.Y.Z**: X代表基础版本号；Y表示从X版本派生出的变体序号；Z表示该变体的修订版号。
  - 当为一个CI创建一个新的变体时，如果它基于某个具体版本（如版本2），则会创建一个形式为“2.Y.Z”的变体。例如，如果这是从版本2创建的第一个变体，则命名为“2.1.1”。
  - 如果是从一个已经存在的变体上进一步派生，则Y值递增或保持不变，取决于具体情况。

#### SC1的影响分析

- 变更请求SC1影响了EC1.1.1和EC1.2.2，并涉及为新客户C2所做的修改。

##### EC1、EC1.1 和 EC1.2

- 对于这些配置项，由于它们并没有直接被SC1影响，所以它们的版本更新主要是为了适应下级配置项的变化。比如，EC1增加了版本2.1.1，这意味着可能是因为其下的某些子配置项（如EC1.1.1或EC1.2.2）发生了变化，需要一个新的主版本来支持这些变化。

##### EC1.1.1 和 EC1.2.2

- **EC1.1.1**：原本只有一个版本1，因为受到了SC1的影响，需要为新客户C2创建一个新的变体。根据命名规则，这是从版本1派生的第一个变体，因此命名为“1.1.1”。
- **EC1.2.2**：同理，也是从版本1派生的第一个变体，命名为“1.1.1”。

#### 总结

- **2.1.1**：对于EC1来说，这个版本号表明这是一个新的变体，基于版本2进行的第一次变体创建，可能是为了支持其子配置项（如EC1.1.1或EC1.2.2）的变化。
- **1.1.1**：对于EC1.1.1和EC1.2.2，这两个配置项都是基于版本1进行的第一次变体创建，以满足新客户C2的需求。

因此，在SC1后，不同配置项之所以有不同的版本号增加，主要是根据它们各自的基础版本以及是否需要为特定需求（如新客户C2）创建新的变体来决定的。这种做法确保了软件系统的灵活性和可扩展性，能够针对不同的客户需求提供定制化的解决方案。

## 变更请求SC2后的CI库存状态

进一步应用变更请求SC2后，CI库存再次更新如下：

| 配置项标识 | 版本                  |
| ---------- | --------------------- |
| EC1        | 1, 2, 2.1.1, 3, 2.1.2 |
| EC1.1      | 1, 1.1.1, 2, 1.1.2    |
| EC1.2      | 1, 2, 2.1.1, 3, 2.1.2 |
| EC1.1.1    | 1, 1.1.1, 2, 1.1.2    |
| EC1.1.2    | 1                     |
| EC1.2.1    | 1, 2, 3               |
| EC1.2.2    | 1, 1.1.1              |

这里，“2.1.2”表示从变体2.1.1派生的新变体，“3”是新的主要版本，用于满足两个客户的需要。

在SC2变更请求后，CI库存中的版本变化反映了针对不同客户需求（C1和C2）进行的进一步修改。以下是详细的解释：

### SC2后的版本变化

#### 变更请求SC2的影响

- **影响**: EC1.1.1 和 EC1.2.1，面向两个客户（C1和C2）。
- **目的**: 这次变更引入了新的需求或改进，导致需要创建新的变体或版本来满足这些需求。

#### 更新后的CI库存状态

根据提供的解答文档，SC2之后的CI库存更新如下：

| 配置项标识 | 版本                  |
| ---------- | --------------------- |
| EC1        | 1, 2, 2.1.1, 3, 2.1.2 |
| EC1.1      | 1, 1.1.1, 2, 1.1.2    |
| EC1.2      | 1, 2, 2.1.1, 3, 2.1.2 |
| EC1.1.1    | 1, 1.1.1, 2, 1.1.2    |
| EC1.1.2    | 1                     |
| EC1.2.1    | 1, 2, 3               |
| EC1.2.2    | 1, 1.1.1              |

### 具体版本变化解释

1. **EC1**

   - 新增版本 **3**：这表示为了适应SC2的需求，可能需要一个新的主要版本，以确保所有相关的子配置项都能得到相应的支持。
   - 新增版本 **2.1.2**：这是基于之前的变体2.1.1进一步派生的新变体，可能是为了特定需求（如客户C2）所做的调整。
2. **EC1.1**

   - 新增版本 **2**：这是一个新的主要版本，可能是为了适应新的需求而创建的。
   - 新增版本 **1.1.2**：这是基于变体1.1.1进一步派生的新变体，用于满足特定需求（如客户C2）。
3. **EC1.2**

   - 新增版本 **3**：类似于EC1，这是一个新的主要版本，用于支持新的需求。
   - 新增版本 **2.1.2**：基于变体2.1.1进一步派生的新变体，可能是为了解决特定问题或满足特定需求。
4. **EC1.1.1**

   - 新增版本 **2**：一个新的主要版本，可能是为了适应新的需求。
   - 新增版本 **1.1.2**：这是基于变体1.1.1进一步派生的新变体，可能是为了满足客户C2的具体要求。
5. **EC1.2.1**

   - 新增版本 **3**：一个新的主要版本，可能是为了适应新的需求。
6. **EC1.2.2**

   - 没有新增版本，保持原有的版本不变。

### 解释SC2带来的具体变化

- **新版本3**：对于EC1、EC1.1和EC1.2，版本3的引入表明为了满足新的需求或改进，需要一个全新的主版本。这通常意味着较大的改动或功能增强。
- **新变体2.1.2和1.1.2**：这些变体是从之前存在的变体（如2.1.1和1.1.1）进一步派生出来的，主要是为了满足客户C2的特定需求。这些变体允许在不破坏现有系统的情况下，提供定制化的解决方案。
- **EC1.2.1的版本3**：与EC1、EC1.1和EC1.2类似，版本3的引入是为了适应新的需求或改进，确保能够支持最新的变更。

### 总结

SC2带来的版本变化主要是为了应对新的客户需求（如客户C2），通过创建新的主要版本或变体来实现。这种做法不仅确保了系统的灵活性和可扩展性，还使得能够为不同的客户提供定制化的解决方案。每个新的变体或版本都是基于具体的变更需求精心设计的，以保证系统能够在不断变化的需求环境中持续演进。

#### A. CI库存状态展示

- **第一次变更（SC1）后**：

  - EC1: 增加了版本2.1.1。
  - EC1.1: 增加了版本1.1.1。
  - EC1.2: 增加了版本2.1.1。
  - EC1.1.1: 增加了版本1.1.1。
  - EC1.2.2: 增加了版本1.1.1。
- **第二次变更（SC2）后**：

  - EC1: 增加了版本3和2.1.2。
  - EC1.1: 增加了版本2和1.1.2。
  - EC1.2: 增加了版本3和2.1.2。
  - EC1.1.1: 增加了版本2和1.1.2。
  - EC1.2.1: 增加了版本3。

## B. 替代配置的数量

根据变更后的CI库存状态，可以看到存在以下可选配置：

- EC1: 5个版本 (1, 2, 2.1.1, 3, 2.1.2)
- EC1.1: 4个版本 (1, 1.1.1, 2, 1.1.2)
- EC1.2: 5个版本 (1, 2, 2.1.1, 3, 2.1.2)
- EC1.1.1: 4个版本 (1, 1.1.1, 2, 1.1.2)
- EC1.1.2: 1个版本 (1)
- EC1.2.1: 3个版本 (1, 2, 3)
- EC1.2.2: 2个版本 (1, 1.1.1)

由于EC1、EC1.1、EC1.2、EC1.1.1、EC1.2.1 和 EC1.2.2 各自有多个版本或变体，具体计算组合数量较为复杂。但根据提供的解决方案，最终形成了两种主要配置：C1和C2。

为了计算总的组合数，我们只需要将每个配置项的版本数相乘。然而，由于某些配置项之间存在依赖关系（例如EC1.1.1依赖于EC1.1），实际的组合数会少一些。

**注意**: 根据解答文档，最终形成了两种主要配置：C1和C2。这意味着并不是所有可能的组合都被视为有效的配置。具体来说，配置是根据客户需求进行分组的。

## C. 每种替代配置的组成

根据提供的解决方案，展示了两种配置C1和C2的具体组成：

**配置C1**

| 配置项标识 | 版本 |
| ---------- | ---- |
| EC1        | 3    |
| EC1.1      | 2    |
| EC1.2      | 3    |
| EC1.1.1    | 2    |
| EC1.1.2    | 1    |
| EC1.2.1    | 3    |
| EC1.2.2    | 1    |

**配置C2**

| 配置项标识 | 版本  |
| ---------- | ----- |
| EC1        | 2.1.2 |
| EC1.1      | 1.1.2 |
| EC1.2      | 2.1.2 |
| EC1.1.1    | 1.1.2 |
| EC1.1.2    | 1     |
| EC1.2.1    | 3     |
| EC1.2.2    | 1.1.1 |

**配置C1** 和 **配置C2** 分别代表了满足不同客户需求的两种配置方式。- **配置C1** 使用的是较新的主版本（如版本3），适用于需要最新功能和改进的客户。

- **配置C2** 使用的是从之前版本派生的变体（如2.1.2、1.1.2），可能是为了保持与现有系统的兼容性或其他特定需求。

这些配置分别对应了不同客户的需求，确保每个客户都能获得满足其特定需求的产品版本。通过这种方式，可以有效地管理软件产品在面对不同客户需求时的演变过程。
